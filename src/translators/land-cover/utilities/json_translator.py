################################################################################
#                                                                              #
#                              json_translator.py                              #
#                                                                              #
################################################################################
#                                                                              #
#        This is a class for translating Land Cover data.                      #
#                                                                              #
#        Author(s): Abe Megahed                                                #
#                                                                              #
#        This file is subject to the terms and conditions defined in           #
#        'LICENSE.txt', which is part of this source code distribution.        #
#                                                                              #
################################################################################
#        Copyright (C) 2025 - Global Mosquito Observations Dashboard           #
################################################################################

import os

#
# globals
#

current = os.path.dirname(os.path.abspath(__file__))
schema = current + '/output_schema.txt'

#
# class
#

class LandCoverTranslator:
	columns = []
	count = 0

	#
	# constructor
	#

	def __init__(self):
		global schema

		# read schema
		#
		with open(schema, 'r') as file:
			for line in file:
				column = line.replace(',', '').replace('REQUIRED', '').replace('MANDATORY', '').strip()
				if not column.startswith('//'):
					self.columns.append(column)

	#
	# converting methods
	#

	def object_to_array(self, object):

		"""
		Convert an object to an array of values.

		Args:
			object (dict): An associative array.

		Returns:
			array: The array of values.
		"""

		values = []
		for key in object:
			values.append(object[key])
		return values

	#
	# translation methods
	#

	def translate_value(self, key, observation):

		"""
		Translate a value with a particular name (key) from an observation.

		Args:
			key: the name of the desired field.
			observation (dict): The observation data.

		Returns:
			object: The translated value.
		"""

		data = observation['data']

		match key:

			case 'OBJECTID':
				self.count += 1
				return self.count

			case 'title':
				return 'Globe Land Cover v1.0.0 OGC'

			case 'description':
				return 'Land Cover Data Generated by Globe'

			case 'dataStreamName':
				return 'Globe Land Cover v1.0.0.0 OGC' + str(observation['organizationId']) + ':' + str(observation['siteId'])

			case 'dataStreamDescription':
				return {
					'title': 'Globe Land Cover v1.0.0 OGC', 
					'lc_LandCoverId': observation['organizationId'], 
					'lc_siteId': observation['siteId'], 
					'lc_Userid': ''
				}

			case 'observationType':
				return 'category'

			case 'unitOfCategory':
				return {
					"name": "classification", 
					"symbol": "none",
					"definition": "n/a",
					"sensor use": "yes"
				}

			case 'projectObservationUID':
				return str(observation['pid']) + ':' + str(observation['siteId'])

			case 'phenomenonTime':
				return observation['measuredDate']

			case 'resultTime':
				return observation['measuredDate']

			case 'result':
				return {
					'lc_PrimaryClassification': 'NA', 
					'lc_SecondaryClassification': 'NA', 
					'lc_EastClassifications': '', 
					'lc_WestClassifications': '', 
					'lc_NorthClassifications': '', 
					'lc_SouthClassifications': ''
				}

			case 'submitTime':
				return observation['createDate']

			case 'imageStatus':
				return 1

			case 'imageResult':
				return {
					'lc_UpwardPhotoUrl': data['landcoversUpwardPhotoUrl'], 
					'lc_DownwardPhotoUrl': data['landcoversDownwardPhotoUrl'], 
					'lc_EastPhotoUrl': data['landcoversEastPhotoUrl'], 
					'lc_WestPhotoUrl': data['landcoversWestPhotoUrl'], 
					'lc_NorthPhotoUrl': data['landcoversNorthPhotoUrl'], 
					'lc_SouthPhotoUrl': data['landcoversSouthPhotoUrl']
				}

			case 'lc_UpwardPhotoUrl':
				return data['landcoversUpwardPhotoUrl']

			case 'lc_DownwardPhotoUrl':
				return data['landcoversDownwardPhotoUrl']

			case 'lc_EastPhotoUrl':
				return data['landcoversEastPhotoUrl']

			case 'lc_WestPhotoUrl':
				return data['landcoversWestPhotoUrl']

			case 'lc_NorthPhotoUrl':
				return data['landcoversNorthPhotoUrl']

			case 'lc_SouthPhotoUrl':
				return data['landcoversSouthPhotoUrl']

			case 'parameters':
				return {
					'lc_DownwardCaption': data['landcoversDownwardCaption'], 
					'lc_DownwardExtraData': data['landcoversDownwardExtraData'], 
					'lc_EastCaption': data['landcoversEastCaption'], 
					'lc_EastExtraData': data['landcoversEastExtraData'], 
					'lc_NorthCaption': data['landcoversNorthCaption'], 
					'lc_NorthExtraData': data['landcoversNorthExtraData'], 
					'lc_SouthCaption': data['landcoversSouthCaption'], 
					'lc_SouthExtraData': data['landcoversSouthExtraData'], 
					'lc_UpwardCaption': data['landcoversUpwardCaption'], 
					'lc_UpwardExtraData': data['landcoversUpwardExtraData'], 
					'lc_WestCaption': data['landcoversWestCaption'], 
					'lc_WestExtraData': data['landcoversWestExtraData'], 
					'lc_MGRSLatitude': data['landcoversMeasurementLatitude'] if 'landcoversMeasurementLatitude' in data else '',  
					'lc_MGRSLongitude': data['landcoversMeasurementLongitude'] if 'landcoversMeasurementLongitude' in data else '', 
					'lc_elevation': data['landcoversMeasurementElevation'] if 'landcoversMeasurementElevation' in data else '', 
					'lc_CumulativeCompletenessScore': '',  
					'lc_SubCompletenessScore': '',  
					'lc_LocationAccuracyM': data['landcoversLocationAccuracyM'],  
					'lc_LocationMethod': data['landcoversLocationMethod']
				}

			case 'licenseName':
				return 'NA'

			case 'licenseURI':
				return 'https://www.globe.gov/documents/10157/2592674/GLOBE+Data+User+Guide_v1_final.pdf/863a971d-95c5-4dd9-b75c-46713f019088'

			case 'attributionDataAggregator':
				return 'Global Learning and Observations to Benefit the Environment (GLOBE)'

			case 'validationStatus':
				return 1

			case 'validationMethod':
				return "Validation method is as follows: 1) GLOBE Observer App has its own validators to ensure the requested data type matches the received value. 2) GLOBE Observer Team validates the photos to ensure they are useful and match the area where the photographer took the photo. 3) Our pre-processing algorithms ensure values entered are appropriate and reasonable. Our code also creates quality assurance flags to allow Users to better summarize the data."

			case 'validationResult':
				return "FALSE - Entries with their photos undergoing GLOBE validation process will have a 'pending' code for their photos. NOTE: Some photos will be listed as 'rejected'. Photos that pass our validation process will include GLOBE's URL to that photo"

			case 'qualityDescription':
				return "GLOBE Observer Data Guide: https://www.globe.gov/documents/10157/2592674/GLOBE+Data+User+Guide_v1_final.pdf/863a971d-95c5-4dd9-b75c-46713f019088 (Page 25) | Our Code Documentation: https://iges-geospatial.github.io/globe-observer-utils-docs/go_utils/mhm.html"

			case 'qualityGrade':
				return 'research'

			case 'observedPropertyName':
				return 'Land Cover Photos'

			case 'observedPropertyDescription':
				return 'The primary and secondary Land Cover Classifications for an area'

			case 'observedPropertyDefinition':
				return 'Land Cover as documented by photographs'

			case 'sensorName':
				return 'NA'

			case 'sensorDescription':
				return 'NA'

			case 'locationName':
				return observation['siteName']

			case 'locationDescription':
				return 'Site ID:' + str(observation['siteId'])

			case 'locationEncodingType':
				return 'GeoJSON'

			case 'latitude':
				return observation['latitude']

			case 'longitude':
				return observation['longitude']

			case 'elevation':
				return observation['elevation']

			case 'thingName':
				return str(observation['pid'])
				# return str(observation['pid']) + ':' + str(observation['organizationId']),

			case 'thingDescription':
				return {
					'lc_organizationName': observation['organizationName'], 
					'lc_PhotoCount': '', 
					'lc_RejectedCount': '', 
					'lc_PendingCount': '', 
					'lc_EmptyCount': ''
				}

			case 'featureName':
				return observation['siteName']

			case 'featureDescription':
				return ''

			case 'featureEncodingType':
				return 'GeoJSON'

			case 'featureLocation':
				return '[' + str(observation['latitude']) + ',' + str(observation['longitude']) + ']'

			case 'Speed (km/h)':
				return ''

			case 'Direction of travel (°)':
				return ''

			case 'Compass reading (°)':
				return ''

			case 'Position source type':
				return ''

			case 'Receiver Name':
				return ''

			case 'Horizontal Accuracy (m)':
				return ''

			case 'Vertical Accuracy (m)':
				return ''

			case 'Latitude':
				return observation['latitude']

			case 'Longitude':
				return observation['longitude']

			case 'Altitude':
				return ''

			case 'PDOP':
				return ''

			case 'HDOP':
				return ''

			case 'VDOP':
				return ''

			case 'Fix Type':
				return ''

			case 'Correction Age':
				return ''

			case 'Station ID':
				return ''

			case 'Number of Satellites':
				return ''

			case 'Fix Time':
				return ''

			case 'Average Horizontal Accuracy (m)':
				return ''

			case 'Average Vertical Accuracy (m)':
				return ''

			case 'Averaged Positions':
				return ''

			case 'Standard Deviation (m)':
				return ''

			case 'x':
				return observation['longitude']

			case 'y':
				return observation['latitude']

		return ''

	def translate_observation(self, observation):

		"""
		Translate an observation.

		Args:
			observation (dict): The observation data.

		Returns:
			object: The set of values.
		"""

		values = {}
		for column in self.columns:
			values[column] = self.translate_value(column, observation) or ''
		return values

	def translate_observations(self, observations):

		"""
		Translate an array of observations.

		Args:
			observations (array): The array of observations.

		Returns:
			object: array of sets of values.
		"""

		values = []
		if len(observations) > 0:
			for observation in observations:
				values.append(self.translate_observation(observation))
		return values